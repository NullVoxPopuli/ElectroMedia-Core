#include "stdafx.h"
#include "FFTPreprocessing.h"
#include <math.h>

// long = obtainDataFromFile(char*, int*)
// ---
// Reads a file generated by FFMPEG into memory. The data array (in integers)
// is returned via dataOut and the length of the file is returned as a long
//
// This is, unfortunately, separated from obtainDataFromFile because we need
// a way to accurately determine the filesize in order to initialize a data
// array of the correct size. I will look into a way of combining these,
// but right now this is the only way to do it
//
// Performance: O(n)
long calculateDataFileSize(char* fileName)
{	
	// Read the file indicated by Filename argument
	std::ifstream dataFileIn_(fileName, std::ios::binary);
	
	long counted_ = 0;
	while (dataFileIn_)
	{
		// Get the next line from the FFTW file
		char c;
		dataFileIn_.get(c);

		// If it exists, push it into the dataOut array
		if (dataFileIn_)
		{
			counted_++;
		}
	}

	// Close the file and then return the filesize
	dataFileIn_.close();
	return counted_;
}

int* obtainDataFromFile(char* fileName, long fileSize)
{	
	// Read the file indicated by Filename argument
	std::ifstream dataFileIn_(fileName, std::ios::binary);
	int* dataOut = new int[fileSize];

	long counted_ = 0;
	while (dataFileIn_ && counted_ < fileSize)
	{
		// Get the next line from the FFTW file
		char c;
		dataFileIn_.get(c);

		// If it exists, push it into the dataOut array
		if (dataFileIn_)
		{
			dataOut[counted_++] = int(c);
		}
	}

	// Close the file and then return the filesize
	dataFileIn_.close();
	return dataOut;
}

// copyAndPadData(double*, double*, int)
// ---
// Copies all of the data from dataIn to dataOut, while also zero-padding the points
// where there is no actual data to copy
double* copyAndPadData(const double* dataIn)
{
	double* dataOut = new double[WINDOW_SIZE];

	for(int i = 0; i < WINDOW_SIZE; i++)
	{
		dataOut[i] = dataIn[i] ? dataIn[i] : 0;
	}

	return dataOut;
}

// fftw_complex* =  startFFT (double*, int)
// ---
// Interface with the FFTW FOSS library. Indirectly performs the Fast Fourier
// Transform to the data set of length (int)
fftw_complex* fastFourierTransform(const double* data)
{
	// Allocate memory for the fftw_complex array and working double*
	double* workingDoubleArray_ = new double[WINDOW_SIZE];// (double *)malloc(sizeof(double) * WINDOW_SIZE);
	fftw_complex* out = (fftw_complex *)fftw_malloc(sizeof(fftw_complex) * WINDOW_SIZE);

	// Generate a plan for FFTW to execute
	fftw_plan new_plan = fftw_plan_dft_r2c_1d(WINDOW_SIZE, workingDoubleArray_, out, FFTW_MEASURE);
	
	// workingDoubleArray_ is called via reference in fftw_execute
	workingDoubleArray_ = copyAndPadData(data);

	// Execute the plan
	fftw_execute(new_plan);

	// Clean up workingDoubleArray_
	delete[] workingDoubleArray_;

	// Return the array of fftw_complex objects
	return out;
}

// normalize(double*, int)
// ---
// Takes an array of (int) doubles as the data set, iterates through to find the max
// value, and then normalizes the original data set based on that maximum.
//
// Performance: O(n)
void normalize(double* data)
{
	double maxOfData_ = -1;

	// Iterate through the input data looking for the maximum
	for(int i = 0; i < WINDOW_SIZE; i++)
	{
		maxOfData_ = (maxOfData_ < data[i] ? data[i] : maxOfData_);
	}

	// Once we have the max, use it to normalize the data set
	for(int i = 0; i < WINDOW_SIZE; i++)
	{
		data[i] /= maxOfData_;
	}
}

// double = hanningMultiplier(int, int)
// ---
// Returns an offset cosine wave of (int) width at a specific index
double hanningMultiplier(int indexOfHanningFunction)
{
	return 0.5 * (1 - cos(2*PI * indexOfHanningFunction / (WINDOW_SIZE-1)) );
}

// applyHanningWindow(int*, double*, int)
// ---
// Takes an array of (int) points in the time domain (int) and applies a Hanning Window
// of specified width. The result is returned through the double* dataOut argument.
// Immediately normalizes the data after the hanning window is applied.
//
// Performance: O(n)
double* applyHanningWindow(const int* dataIn)
{
	double* dataOut = new double[WINDOW_SIZE];

	// Actually go through each point of the original function and multiply it by the 
	// correct value of the Hanning window function at that point in time
	for (int indexAt = 0; indexAt < WINDOW_SIZE; indexAt++)
	{
		dataOut[indexAt] = hanningMultiplier(indexAt) * double(dataIn[indexAt]);
	}

	// Normalize the data before we finish
	normalize(dataOut);

	return dataOut;
}

// double* = prepareAndExecuteFFT(const int*)
// ---
// Execute the FFT, convert the results from the complex frequency domain to the
// frequency-vs-time spectral domain and then save the results into a debug file.
double* prepareAndExecuteFFT(const int* dataIn)
{
	double* windowedData = applyHanningWindow(dataIn);
	double* dataOut = new double[WINDOW_SIZE];

	// Execute the FFT
	fftw_complex* results = fastFourierTransform(windowedData);
	std::ofstream fftResultsFile ("Results.csv");

	// Iterate through the results up to the Maximum Frequency we care about, then
	// convert the data from the complex frequency domain to spectral frequency
	for(int i=0; i<convertFrequencyToInt(MAXIMUM_FREQUENCY_ACCOUNTED); i++)
	{		
		// This uses the simplified complex distance formula
		dataOut[i] = sqrt(results[i][0]*results[i][0] + results[i][1]*results[i][1]);

		// Put the spectral data into the .csv matched up with its frequency
		fftResultsFile << (BOUNDARY_CONVERSION_SCALAR*i - BOUNDARY_CONVERSION_OFFSET) << "," << int(dataOut[i]) << endl;
	}

	fftResultsFile.close();
	return dataOut;
}