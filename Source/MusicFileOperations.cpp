#include "stdafx.h"
#include "MusicFileOperations.h"

MusicFileOperations::MP3FileData MusicFileOperations::GetDataFromMP3()
{
	auto returnCode = DecodeMusic();

	if (returnCode != FFmpegReturnValue::Success)
	{
		std::cerr << "Exiting program with code " << returnCode;
		throw;
	}

	// Process the raw data file and put the data into fulldata
	auto data_from_file = std::make_shared<vector<char>>();
	
	MusicFileOperations::CaptureFileData(data_from_file);

	return data_from_file;
}

void MusicFileOperations::ConvertMP3ToARF()
{
	auto data_from_file = MusicFileOperations::GetDataFromMP3();

    // preProcessData is an empty integer array that is used to receive data via memcpy.
    // It is rewritten in every loop, whereas dataFromFile is constant.
    DataSet preProcessData = DataSet();
    vector<char>::const_iterator first, last;
	auto sweeps = -1;

	auto window_size = Settings.window_size_;
	auto window_shift = Settings.window_shift_amount_;


    // FFT variables
	// MOST of this should be refactored into LinearAnalyzer
    auto workingDoubleArray_ = (double*)fftw_malloc(sizeof(double) * window_size);
	auto complexResults = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * window_size);
	auto new_plan = fftw_plan_dft_r2c_1d(window_size, workingDoubleArray_, complexResults, FFTW_MEASURE);

	CoreMath::Debug("Converting \"" + EmcSettings::GetInstance().song_filename_ + "\" to Arduino Readable File");
	while (((++sweeps)*window_shift + window_size) < data_from_file->size())
    {
        // Copy out the data from the AudioFileData source into a DataSet
		first = data_from_file->begin() + sweeps*window_shift;
		last = data_from_file->begin() + sweeps*window_shift + window_size;
        vector<double> windowedSubvector(first, last);
        preProcessData = std::make_shared<vector<double>>(windowedSubvector);

        // Call FFT
        auto dataFromFFT = PrepareAndExecuteFFT(preProcessData, new_plan, workingDoubleArray_, complexResults);
        //arfile->Write(dataFromFFT);
    }
    CoreMath::Debug("Process complete.");
    
    // Cleanup
    fftw_destroy_plan(new_plan);
    fftw_free(workingDoubleArray_);
    fftw_free(complexResults);
    fftw_cleanup();
    //arfile->Close();
}

// Should probably be moved into EmcCore


void MusicFileOperations::CopyVectorToPointerArray(DataSet& vector_in, double* array_out)
{
    auto elements = 0;
	auto dataSetIterator = vector_in->begin();

	while (dataSetIterator != vector_in->end() && elements++ < vector_in->size())
    {
		array_out[elements] = *dataSetIterator;
		++dataSetIterator;
    }
}

// long = obtainDataFromFile(char*, int*)
// ---
// Reads a file generated by FFMPEG into memory. The data array (in integers)
// is returned via dataOut and the length of the file is returned as a long
//
// This is, unfortunately, separated from obtainDataFromFile because we need
// a way to accurately determine the filesize in order to initialize a data
// array of the correct size. I will look into a way of combining these,
// but right now this is the only way to do it
//
// Performance: O(n)
long MusicFileOperations::CaptureFileData(AudioFileData& waveform_data)
{
    // Read the file indicated by Filename argument
	std::ifstream data_file_stream((Settings.song_filename_ + Settings.kEmcFileExtension).c_str(), std::ios::binary);

    long counted_points = 0;
	while (data_file_stream)
    {
        // Get the next line from the FFTW file
        char c;
		data_file_stream.get(c);

        // If it exists, push it into the dataOut array
		if (data_file_stream)
        {
			waveform_data->push_back(double(c));
			++counted_points;
        }
    }

    // Close the file and then return the filesize
	data_file_stream.close();
	return counted_points;
}

// fftw_complex* =  startFFT (double*, int)
// ---
// Interface with the FFTW FOSS library. Indirectly performs the Fast Fourier
// Transform to the data set of length (int)
DataSet MusicFileOperations::ExecuteFastFourierTransform(DataSet& data, fftw_plan& fft_plan, double* working_array, fftw_complex* complex_results)
{
    // Allocate memory for the fftw_complex array and working double*
    // Generate a plan for FFTW to execute
	memcpy(working_array, &data->at(0), data->size() * sizeof(double));
    
	// Execute the plan
    fftw_execute(fft_plan);

   // std::ofstream fftResultsFile("Results.csv");
    vector<double> results_vector;
	results_vector.reserve(180);
	auto data_out = std::make_shared<vector<double>>(results_vector);

    auto frequency = 0.0;
    for(int i=0; i < 180; i++)
    {
		frequency = double(sqrt(complex_results[i][0] * complex_results[i][0] + complex_results[i][1] * complex_results[i][1]));
        data_out->push_back( frequency );
    }


  //  fftResultsFile.close();
	return data_out;
}

// normalize(double*, int)
// ---
// Takes an array of (int) doubles as the data set, iterates through to find the max
// value, and then normalizes the original data set based on that maximum.
//
// Performance: O(n)
void MusicFileOperations::Normalize(DataSet& data)
{
    auto max_value = *std::max_element(data->begin(), data->end());

	std::for_each(data->begin(), data->end(), [max_value](double& x){ x /= max_value; });
}

// double = hanningMultiplier(int, int)
// ---
// Returns an offset cosine wave of (int) width at a specific index
double MusicFileOperations::GetHanningMultiplier(int index_at)
{
	return 0.5 * (1 - cos(2 * 3.14 * index_at / (Settings.window_size_ - 1)));
}

// applyHanningWindow(int*, double*, int)
// ---
// Takes an array of (int) points in the time domain (int) and applies a Hanning Window
// of specified width. The result is returned through the double* dataOut argument.
// Immediately normalizes the data after the hanning window is applied.
//
// Performance: O(n)
void MusicFileOperations::ApplyHanningWindow(DataSet& data)
{
    auto index = int(0);
    for (DataSetIterator it = data->begin(); it != data->end(); ++it)
    {
        *it = double(*it * GetHanningMultiplier(++index));
    }

    Normalize(data);
}

// double* = prepareAndExecuteFFT(const int*)
// ---
// Execute the FFT, convert the results from the complex frequency domain to the
// frequency-vs-time spectral domain and then save the results into a debug file.
DataSet MusicFileOperations::PrepareAndExecuteFFT(DataSet& data, fftw_plan& fft_plan, double* working_array, fftw_complex* complex_results)
{
	auto maxFrequency = CoreMath::ConvertFrequencyToInt(Settings.maximum_frequency_accounted_);

    // Execute the FFT
    ApplyHanningWindow(data);
	return ExecuteFastFourierTransform(data, fft_plan, working_array, complex_results);
}